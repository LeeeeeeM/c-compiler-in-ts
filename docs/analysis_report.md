# CPC 编译器完整分析报告

## 项目概述

CPC 是一个用 C 语言编写的 C 编译器，基于著名的 C4 编译器实现。整个项目仅用 700 行代码就实现了一个功能完整的 C 编译器，具有自举能力。

## 核心架构

### 三层架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        CPC 编译器架构                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│  │   前端模块   │    │   中端模块   │    │   后端模块   │         │
│  │             │    │             │    │             │         │
│  │ ┌─────────┐ │    │ ┌─────────┐ │    │ ┌─────────┐ │         │
│  │ │词法分析  │ │───▶│ │语法分析  │ │───▶│ │代码生成  │ │         │
│  │ │tokenize │ │    │ │parse    │ │    │ │VM指令   │ │         │
│  │ └─────────┘ │    │ └─────────┘ │    │ └─────────┘ │         │
│  │             │    │             │    │             │         │
│  │ ┌─────────┐ │    │ ┌─────────┐ │    │ ┌─────────┐ │         │
│  │ │符号表    │ │    │ │表达式    │ │    │ │虚拟机    │ │         │
│  │ │symbol   │ │    │ │parse_expr│ │    │ │run_vm   │ │         │
│  │ └─────────┘ │    │ └─────────┘ │    │ └─────────┘ │         │
│  └─────────────┘    └─────────────┘    └─────────────┘         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 编译流程

### 主要步骤

1. **源码加载** (`load_src`)
   - 读取 C 源文件到内存
   - 添加字符串结束符

2. **虚拟机初始化** (`init_vm`)
   - 分配代码段、数据段、栈段内存
   - 初始化符号表

3. **关键字初始化** (`keyword`)
   - 设置 C 语言关键字
   - 注册系统调用函数

4. **语法分析** (`parse`)
   - 词法分析 (`tokenize`)
   - 语法分析生成 VM 指令
   - 符号表管理

5. **代码生成**
   - 生成虚拟机指令序列
   - 输出调试汇编代码 (`write_as`)

6. **虚拟机执行** (`run_vm`)
   - 执行生成的 VM 指令
   - 处理函数调用和栈管理

## 虚拟机设计

### 内存布局

```
┌─────────────────────────────────────────────────────────────────┐
│                        虚拟机内存布局                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   代码段     │  │   数据段     │  │   栈段      │             │
│  │  code[]     │  │  data[]     │  │  stack[]    │             │
│  │             │  │             │  │             │             │
│  │ VM指令序列   │  │ 全局变量     │  │ 函数调用栈   │             │
│  │ IMM, LEA... │  │ 字符串常量   │  │ 局部变量     │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                 │
│  ┌─────────────┐                                               │
│  │   符号表     │                                               │
│  │symbol_table │                                               │
│  │             │                                               │
│  │ 函数/变量    │                                               │
│  │ 类型信息     │                                               │
│  └─────────────┘                                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 寄存器设计

- **pc** (Program Counter): 程序计数器，指向当前执行的指令
- **sp** (Stack Pointer): 栈指针，指向栈顶
- **bp** (Base Pointer): 基址指针，指向当前函数栈帧基址
- **ax** (Accumulator): 累加器，存储计算结果

### 指令集

**数据操作指令**:
- `IMM`: 加载立即数
- `LEA`: 加载局部地址
- `LI/LC`: 加载整数/字符
- `SI/SC`: 存储整数/字符
- `PUSH`: 压栈

**控制流指令**:
- `JMP`: 无条件跳转
- `JZ/JNZ`: 条件跳转
- `CALL`: 函数调用
- `RET`: 函数返回

**算术运算指令**:
- `ADD/SUB/MUL/DIV/MOD`: 基本算术运算
- `SHL/SHR`: 位移运算
- `OR/XOR/AND`: 位运算
- `EQ/NE/LT/GT/LE/GE`: 比较运算

**函数调用指令**:
- `NVAR`: 创建新的栈帧
- `DARG`: 删除参数栈帧

**系统调用指令**:
- `OPEN/READ/CLOS`: 文件操作
- `PRTF`: 格式化输出
- `MALC/FREE`: 内存管理
- `MSET/MCMP`: 内存操作
- `EXIT`: 程序退出

## 核心算法

### 1. 词法分析算法

使用状态机方式处理字符流：
- 标识符识别：字母开头，支持字母数字下划线
- 数字识别：支持十进制、十六进制(0x)、八进制(0开头)
- 字符串处理：支持转义字符
- 运算符识别：单字符和双字符运算符

### 2. 语法分析算法

使用递归下降解析器：
- **表达式解析**: 优先级爬山算法
- **语句解析**: 递归下降
- **函数解析**: 栈帧管理

### 3. 优先级爬山算法

用于表达式解析，支持所有 C 语言运算符：

```
Assign < Cond < Lor < Land < Or < Xor < And < Eq < Ne < Lt < Gt < Le < Ge < Shl < Shr < Add < Sub < Mul < Div < Mod < Inc < Dec < Brak
```

## 符号表管理

### 符号表结构

```c
enum {Token, Hash, Name, Class, Type, Value, GClass, GType, GValue, SymSize};
```

- **Token**: 符号类型
- **Hash**: 哈希值，用于快速查找
- **Name**: 符号名称
- **Class**: 符号类别 (Fun/Sys/Glo/Loc/Id)
- **Type**: 数据类型 (CHAR/INT/PTR)
- **Value**: 符号值
- **GClass/GType/GValue**: 全局符号信息备份

### 作用域管理

- 支持局部变量和全局变量
- 使用 `hide_global()` 和 `recover_global()` 管理作用域
- 函数参数和局部变量使用栈帧管理

## 支持的 C 语言特性

### 数据类型
- `int`: 64位整数
- `char`: 8位字符
- 指针类型和指针运算

### 控制结构
- `if-else`: 条件语句
- `while`: 循环语句
- `return`: 返回语句

### 表达式
- 所有基本运算符
- 指针运算
- 类型转换

### 函数
- 函数定义和调用
- 参数传递
- 栈帧管理

### 其他特性
- 枚举类型
- 局部变量和全局变量
- 系统调用支持

## 设计亮点

1. **简洁性**: 仅 700 行代码实现完整编译器
2. **自举能力**: 编译器可以编译自己
3. **虚拟机架构**: 使用栈式虚拟机，便于理解和调试
4. **递归下降**: 语法分析使用递归下降，结构清晰
5. **优先级爬山**: 高效的表达式解析算法
6. **符号表管理**: 支持作用域和符号查找

## 测试验证

编译器已通过以下测试用例验证：

1. **hello.c**: 基本输出功能
2. **add.c**: 算术运算
3. **fibonacci.c**: 递归函数调用

所有测试用例均运行正常，证明编译器功能完整。

## 总结

CPC 编译器是一个优秀的教学和研究项目，展示了如何用最少的代码实现一个功能完整的编译器。它采用了经典的编译器设计模式，包括词法分析、语法分析、代码生成和虚拟机执行，是学习编译器原理的绝佳例子。
