# CPC TypeScript 编译器架构

## 概述

CPC TypeScript 编译器是一个完整的 C 语言编译器实现，采用经典的编译原理架构，将 C 源代码编译为虚拟机指令，然后通过虚拟机执行。整个编译器采用模块化设计，每个模块负责编译过程的不同阶段。

## 架构图

```
C 源代码 → Lexer → Parser → CodeGenerator → VirtualMachine
    ↓         ↓        ↓           ↓              ↓
  词法分析   语法分析   代码生成    虚拟机执行      程序输出
```

## 核心模块

### 1. 类型系统 (`types.ts`)

**职责**: 定义编译器和虚拟机使用的所有数据类型和枚举

**核心类型**:
- `TokenType`: 词法单元类型（标识符、数字、运算符等）
- `SymbolType`: 符号类型（INT、CHAR、指针类型）
- `SymbolClass`: 符号类别（全局变量、局部变量、函数）
- `Instruction`: 虚拟机指令枚举
- `VMState`: 虚拟机状态结构
- `Precedence`: 运算符优先级

**关键特性**:
- 支持指针类型和数组类型
- 完整的运算符优先级定义
- 虚拟机指令集定义

### 2. 词法分析器 (`lexer.ts`)

**职责**: 将 C 源代码转换为词法单元序列

**核心功能**:
- **字符扫描**: 逐个字符读取源代码
- **词法单元识别**: 识别标识符、数字、字符串、运算符等
- **字符串处理**: 处理字符串常量并存储到数据段
- **注释处理**: 跳过单行和多行注释
- **错误处理**: 报告词法错误

**输出**: `Token` 对象序列，包含类型、值、位置信息

**示例**:
```typescript
// 输入: "int x = 42;"
// 输出: [
//   { type: TokenType.Int, value: "int" },
//   { type: TokenType.Id, value: "x" },
//   { type: TokenType.Assign, value: "=" },
//   { type: TokenType.Num, value: 42 },
//   { type: TokenType.Semicolon, value: ";" }
// ]
```

### 3. 语法分析器 (`parser.ts`)

**职责**: 根据 C 语言语法规则解析词法单元序列

**核心功能**:
- **语法规则实现**: 实现 C 语言的语法规则
- **AST 构建**: 构建抽象语法树（虽然这里简化了）
- **错误恢复**: 语法错误时的错误恢复机制
- **符号表管理**: 与符号表交互，管理变量和函数

**解析规则**:
- 函数定义和声明
- 变量声明和初始化
- 表达式解析
- 语句解析（if、while、return等）
- 类型解析（int、char、指针）

### 4. 符号表 (`symbol-table.ts`)

**职责**: 管理程序中的所有符号（变量、函数、类型）

**核心功能**:
- **符号存储**: 存储变量、函数、类型信息
- **作用域管理**: 支持嵌套作用域和变量遮蔽
- **类型系统**: 支持基本类型、指针类型、数组类型
- **查找机制**: 高效的符号查找和插入

**符号信息**:
```typescript
interface Symbol {
  name: string;           // 符号名称
  type: SymbolType;       // 符号类型
  class: SymbolClass;     // 符号类别
  value: any;            // 符号值（地址或常量）
  isArray?: boolean;     // 是否为数组
  arraySize?: number;    // 数组大小
}
```

**作用域管理**:
- 全局作用域
- 函数作用域
- 块作用域
- 支持变量遮蔽（局部变量遮蔽全局变量）

### 5. 代码生成器 (`code-generator.ts`)

**职责**: 将语法分析结果转换为虚拟机指令序列

**核心功能**:
- **指令生成**: 生成虚拟机指令
- **地址分配**: 为变量和函数分配地址
- **优化**: 简单的代码优化
- **汇编输出**: 生成可读的汇编代码

**指令类型**:
- **加载指令**: IMM（立即数）、LEA（地址）、LI（加载整数）
- **存储指令**: SI（存储整数）、SC（存储字符）
- **运算指令**: ADD、SUB、MUL、DIV等
- **控制指令**: JMP、JZ、JNZ、CALL、RET
- **系统调用**: PRTF（打印）、EXIT（退出）

**代码生成策略**:
- 栈式虚拟机指令
- 基于寄存器的操作（AX寄存器）
- 函数调用约定
- 局部变量和参数处理

### 6. 虚拟机 (`vm.ts`)

**职责**: 执行生成的虚拟机指令

**核心组件**:
- **指令执行器**: 执行虚拟机指令
- **内存管理**: 管理代码段、数据段、栈
- **函数调用**: 处理函数调用和返回
- **系统调用**: 实现基本的系统调用

**内存布局**:
```
高地址 ┌─────────────┐
       │    栈空间    │ ← SP (栈指针)
       ├─────────────┤
       │   数据段     │ ← 全局变量、字符串常量
       ├─────────────┤
       │   代码段     │ ← PC (程序计数器)
低地址 └─────────────┘
```

**寄存器**:
- **PC**: 程序计数器，指向当前执行的指令
- **SP**: 栈指针，指向栈顶
- **BP**: 基指针，指向当前栈帧
- **AX**: 累加器，用于运算和临时存储

**指令执行**:
- 取指：从代码段读取指令
- 译码：解析指令操作码和操作数
- 执行：执行指令操作
- 更新：更新PC和寄存器状态

### 7. 编译器主控制器 (`compiler.ts`)

**职责**: 协调各个模块，提供统一的编译接口

**核心功能**:
- **编译流程控制**: 协调词法分析、语法分析、代码生成
- **错误处理**: 统一的错误处理和报告
- **配置管理**: 管理编译器配置选项
- **调试支持**: 提供调试信息和汇编输出

**编译流程**:
1. 创建 Parser（内部创建 Lexer）
2. 执行语法分析
3. 创建 CodeGenerator
4. 生成代码和汇编
5. 创建 VirtualMachine
6. 执行程序

## 数据流

### 编译阶段
```
源代码 → 词法分析 → 词法单元 → 语法分析 → 语法树 → 代码生成 → 虚拟机指令
```

### 执行阶段
```
虚拟机指令 → 指令执行 → 内存操作 → 程序输出
```

## 关键特性

### 1. 模块化设计
- 每个模块职责单一
- 模块间接口清晰
- 易于测试和维护

### 2. 类型安全
- TypeScript 提供静态类型检查
- 完整的类型定义
- 编译时错误检测

### 3. 错误处理
- 词法错误检测
- 语法错误检测
- 运行时错误处理
- 友好的错误信息

### 4. 调试支持
- 详细的调试信息
- 汇编代码输出
- 虚拟机状态监控
- 单步执行支持

### 5. 扩展性
- 易于添加新的指令
- 支持新的数据类型
- 可扩展的优化器
- 插件化架构

## 指令集

### 加载和存储
- `IMM arg`: 将立即数加载到AX
- `LEA arg`: 计算地址 `AX = BP + arg`
- `LI`: 从地址加载整数 `AX = data[AX]`
- `LC`: 从地址加载字符 `AX = data[AX]`
- `SI`: 存储整数 `data[pop()] = AX`
- `SC`: 存储字符 `data[pop()] = AX`

### 运算指令
- `ADD`: 加法 `AX = pop() + AX`
- `SUB`: 减法 `AX = pop() - AX`
- `MUL`: 乘法 `AX = pop() * AX`
- `DIV`: 除法 `AX = pop() / AX`
- `MOD`: 取模 `AX = pop() % AX`

### 比较指令
- `EQ`: 等于 `AX = (pop() == AX) ? 1 : 0`
- `NE`: 不等于 `AX = (pop() != AX) ? 1 : 0`
- `LT`: 小于 `AX = (pop() < AX) ? 1 : 0`
- `GT`: 大于 `AX = (pop() > AX) ? 1 : 0`

### 控制流
- `JMP arg`: 无条件跳转到 `arg`
- `JZ arg`: 如果AX为0则跳转到 `arg`
- `JNZ arg`: 如果AX不为0则跳转到 `arg`
- `CALL arg`: 调用函数 `arg`
- `RET`: 函数返回

### 栈操作
- `PUSH`: 将AX压入栈
- `NVAR arg`: 为局部变量分配栈空间
- `DARG arg`: 处理函数参数

### 系统调用
- `PRTF`: 格式化打印
- `EXIT arg`: 程序退出，返回码为 `arg`

## 内存管理

### 栈管理
- 向下增长的栈
- 函数调用栈帧
- 局部变量分配
- 参数传递

### 数据段管理
- 全局变量存储
- 字符串常量
- 静态数据
- 动态扩展支持

### 代码段
- 指令存储
- 程序计数器
- 跳转目标
- 函数入口点

## 优化策略

### 1. 指令级优化
- 常量折叠
- 死代码消除
- 指令合并

### 2. 内存优化
- 栈空间复用
- 数据段压缩
- 垃圾回收（未来）

### 3. 执行优化
- 指令缓存
- 分支预测
- 并行执行（未来）

## 扩展方向

### 1. 语言特性
- 结构体和联合体
- 动态内存分配
- 文件操作
- 多线程支持

### 2. 优化器
- 数据流分析
- 循环优化
- 内联优化
- 寄存器分配

### 3. 工具链
- 链接器
- 调试器
- 性能分析器
- 代码覆盖率工具

## 总结

CPC TypeScript 编译器采用经典的编译原理架构，通过模块化设计实现了完整的 C 语言编译和执行环境。每个模块都有明确的职责，模块间通过清晰的接口进行交互。整个系统具有良好的可扩展性和可维护性，为后续的功能扩展和优化奠定了坚实的基础。

编译器不仅实现了基本的 C 语言特性，还提供了丰富的调试和监控功能，使得开发者可以深入了解程序的执行过程。这种设计使得 CPC 编译器既可以作为学习编译原理的工具，也可以作为实际项目开发的基础。
