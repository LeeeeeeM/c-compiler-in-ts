# CPC编译器函数调用状态图示

## 🎯 函数调用完整状态变化图

### 📊 状态1：调用前准备

```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10           // main的局部变量
├── result1 = ?       // main的局部变量
└── result1的地址     // 压入的地址
栈顶 (低地址) ← sp指向

寄存器状态：
pc = 5369791552 (CALL指令地址)
bp = main的旧bp位置
sp = result1的地址位置
ax = 5 (参数值)
```

### 📊 状态2：CALL指令执行后

```
CALL执行: *--sp = (int)(pc+1); pc = (int*)*pc;

栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10           // main的局部变量
├── result1 = ?       // main的局部变量
├── result1的地址     // 压入的地址
├── 5 (参数)          // 压入的参数
└── 返回地址 (5369791568) // CALL压入 ← sp指向这里
栈顶 (低地址)

寄存器状态：
pc = 5369790472 (test_func函数地址)
bp = main的旧bp位置
sp = 返回地址位置
ax = 5 (参数值)
```

### 📊 状态3：NVAR指令执行后

```
NVAR执行: *--sp = (int)bp; bp = sp; sp = sp - 2;

栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10           // main的局部变量
├── result1 = ?       // main的局部变量
├── result1的地址     // 压入的地址
├── 5 (bp+2)          // 参数
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = ?     // test_func局部变量
└── a3 (bp-2) = ?     // test_func局部变量 ← sp指向这里
栈顶 (低地址)

寄存器状态：
pc = 5369790488 (test_func第一条指令)
bp = 旧bp位置 (栈帧基址)
sp = a3位置 (栈顶)
ax = 5 (参数值)
```

### 📊 状态4：函数执行期间

```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10           // main的局部变量
├── result1 = ?       // main的局部变量
├── result1的地址     // 压入的地址
├── 30 (bp+2)         // 参数 ← 已修改
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (栈帧基址)
├── a2 (bp-1) = 31    // 局部变量 ← 已修改
└── a3 (bp-2) = 40    // 局部变量 ← sp指向这里
栈顶 (低地址)

寄存器状态：
pc = 5369791352 (RET指令地址)
bp = 旧bp位置 (栈帧基址)
sp = a3位置 (栈顶)
ax = 31 (返回值)
```

### 📊 状态5：RET指令执行后

```
RET执行: sp = bp; bp = (int*)*sp++; pc = (int*)*sp++;

栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10           // main的局部变量
├── result1 = ?       // main的局部变量
├── result1的地址     // 压入的地址
├── 5 (参数)          // 压入的参数
└── 返回地址 (5369791568) // CALL压入 ← sp指向这里
栈顶 (低地址)

寄存器状态：
pc = 5369791568 (返回地址)
bp = main的旧bp位置
sp = 返回地址位置
ax = 31 (返回值)
```

### 📊 状态6：DARG和SI执行后

```
DARG 1: sp = sp + 1; (清理参数)
SI: *(int*)*sp++ = ax; (存储返回值)

栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10           // main的局部变量
├── result1 = 31      // main的局部变量 ← 已赋值
└── result1的地址     // 压入的地址 ← sp指向这里
栈顶 (低地址)

寄存器状态：
pc = 5369791592 (下一条指令)
bp = main的旧bp位置
sp = result1的地址位置
ax = 31 (返回值)
```

## 🔄 关键状态转换

### 📈 栈指针(sp)的变化轨迹

```
状态1: sp → result1的地址
状态2: sp → 返回地址 (压入返回地址)
状态3: sp → a3位置 (分配局部变量空间)
状态4: sp → a3位置 (函数执行期间)
状态5: sp → 返回地址 (sp = bp恢复)
状态6: sp → result1的地址 (清理参数)
```

### 📈 基指针(bp)的变化轨迹

```
状态1: bp → main的旧bp位置
状态2: bp → main的旧bp位置 (未变化)
状态3: bp → 旧bp位置 (栈帧基址)
状态4: bp → 旧bp位置 (栈帧基址，未变化)
状态5: bp → main的旧bp位置 (恢复)
状态6: bp → main的旧bp位置 (未变化)
```

### 📈 程序计数器(pc)的变化轨迹

```
状态1: pc → CALL指令地址
状态2: pc → test_func函数地址 (跳转)
状态3: pc → test_func第一条指令
状态4: pc → RET指令地址
状态5: pc → 返回地址 (跳转回main)
状态6: pc → 下一条指令
```

## 🎯 关键理解

### 🔍 栈帧的生命周期

1. **创建阶段**：CALL + NVAR指令
   - CALL：压入返回地址
   - NVAR：压入旧bp，设置新bp，分配局部变量空间

2. **使用阶段**：函数执行期间
   - bp始终指向栈帧基址
   - sp在局部变量区域移动
   - 通过bp偏移访问参数和局部变量

3. **销毁阶段**：RET指令
   - sp = bp：恢复到栈帧基址
   - bp恢复：恢复到调用者的bp
   - pc跳转：跳转到返回地址

### 🔍 关键机制

**为什么`sp = bp`能恢复栈状态？**
- NVAR执行后，bp指向旧bp的位置（栈帧基址）
- 函数执行期间，bp始终指向这个位置
- RET执行时，`sp = bp`让sp回到旧bp位置
- 旧bp位置就是调用前的栈顶位置

**栈帧的"丢弃"机制：**
- RET执行后，局部变量区域不再被访问
- 虽然数据还在内存中，但sp已经移出该区域
- 下次函数调用会覆盖这些位置

## 📊 内存访问模式

### 🎯 参数访问
- `LEA 2` → `(bp+2)` → 访问参数
- `LEA 3` → `(bp+3)` → 访问更多参数

### 🎯 局部变量访问
- `LEA -1` → `(bp-1)` → 访问第一个局部变量
- `LEA -2` → `(bp-2)` → 访问第二个局部变量

### 🎯 全局变量访问
- `IMM 地址` → 直接访问数据段地址

这就是CPC编译器函数调用的完整状态变化过程！
