# CPC编译器main函数执行分析：从入口到栈变化

## 📊 实际地址说明

**重要说明**：本文档基于实际运行 `./cpc example/test.c` 生成的 `assemble` 文件：

- **代码段地址**：基于 `assemble` 文件中的实际地址
  - **test_func 函数地址**：`5369790472` (第1行)
  - **main 函数地址**：`5369791360` (第80行)  
- **数据段地址**：使用 `0x2000` 作为起始地址（示例假设）
  - **全局变量 a1**：`0x2000`
  - **全局变量 a3**：`0x2008`
- **字符串常量地址**：`5370839056` 开始 (数据段中的字符串)

**地址分配机制**：
1. 代码段地址由 `malloc()` 动态分配，记录在 `assemble` 文件中
2. 数据段地址使用 `0x2000` 作为示例起始地址
3. 局部变量通过栈偏移访问 (`LEA -1`, `LEA -2` 等)
4. 每次运行代码段地址可能不同，但相对关系保持一致

---

## 🎯 PC启动和栈初始化

### 📊 PC启动

**PC启动**：
```
PC = 5369791360 (main函数入口，assemble第80行)
```

**run_vm初始栈状态**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
└── tmp (临时指针)
栈顶 (低地址) ← sp指向
```

### 🔍 关键理解

**PC的执行流程**：
1. **启动时**：`pc = main_ptr[Value]` → PC指向main函数
2. **执行main**：PC从main函数开始逐条执行指令
3. **函数调用**：遇到CALL指令时，PC跳转到其他函数
4. **函数返回**：遇到RET指令时，PC返回到调用者

---

## 🏗️ main函数执行过程

### 📊 第80行：NVAR 2 - 创建栈帧

**VM指令**：
```
(5369791360)     NVAR 2
```

**NVAR指令执行**：
```c
// NVAR 2: 创建大小为2的栈帧
*--sp = (int)bp; bp = sp; sp = sp - 2;
```

**执行后栈状态**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = ?     // 局部变量
└── result1 (bp-2) = ? // 局部变量
栈顶 (低地址) ← sp指向
```

### 📈 第81-84行：a1 = 10

**VM指令**：
```
(5369791376)     LEA  -1    // ax = bp + (-1) = a1的地址
(5369791392)     PUSH       // 将a1的地址压入栈
(5369791400)     IMM  10    // ax = 10
(5369791416)     SI         // 将10存储到a1
```

**指令分析**：
1. **LEA -1**：计算a1的地址 (bp + (-1))
2. **PUSH**：将a1的地址压入栈
3. **IMM 10**：加载常量10到ax
4. **SI**：将ax的值存储到栈顶地址指向的位置

**执行后栈状态**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = 10    // 局部变量 ← 已赋值
└── result1 (bp-2) = ? // 局部变量
栈顶 (低地址) ← sp指向
```

### 📊 第85-91行：printf("main: a1=%d\n", a1)

**VM指令**：
```
(5369791424)     IMM  5370839152  // 字符串地址
(5369791440)     PUSH             // 压入字符串地址
(5369791448)     LEA  -1          // ax = a1的地址
(5369791464)     LI               // ax = a1的值 = 10
(5369791472)     PUSH             // 压入a1的值
(5369791480)     PRTF             // 调用printf
(5369791488)     DARG 2           // 清理2个参数
```

**指令分析**：
1. **IMM 5370839152**：加载字符串"main: a1=%d\n"的地址
2. **PUSH**：将字符串地址压入栈
3. **LEA -1 → LI → PUSH**：加载a1的值(10)并压入栈
4. **PRTF**：调用printf函数
5. **DARG 2**：清理2个参数

**执行后栈状态**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = 10    // 局部变量
└── result1 (bp-2) = ? // 局部变量
栈顶 (低地址) ← sp指向
```

### 🎯 第92-98行：result1 = test_func(5)

**VM指令**：
```
(5369791504)     LEA  -2          // ax = result1的地址
(5369791520)     PUSH             // 压入result1的地址
(5369791528)     IMM  5            // ax = 5
(5369791544)     PUSH             // 压入参数5
(5369791552)     CALL 5369790472  // 调用test_func
(5369791568)     DARG 1            // 清理1个参数
(5369791584)     SI                // 将返回值存储到result1
```

**指令分析**：
1. **LEA -2**：计算result1的地址
2. **PUSH**：将result1的地址压入栈
3. **IMM 5**：加载参数5到ax
4. **PUSH**：将参数5压入栈
5. **CALL 5369790472**：调用test_func函数
6. **DARG 1**：清理1个参数
7. **SI**：将返回值存储到result1

**完整的栈状态变化**：

**LEA -2, PUSH 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = 10    // 局部变量
├── result1 (bp-2) = ? // 局部变量
└── result1的地址       // 压入的地址
栈顶 (低地址) ← sp指向
```

**IMM 5, PUSH 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = 10    // 局部变量
├── result1 (bp-2) = ? // 局部变量
├── result1的地址       
└── 5 (参数)           // 压入的参数
栈顶 (低地址) ← sp指向
```

**CALL 5369790472 执行后**：
```
CALL执行: *--sp = (int)(pc+1); pc = (int*)*pc;
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = 10    // 局部变量
├── result1 (bp-2) = ? // 局部变量
├── result1的地址       
├── 5 (参数)           
└── 返回地址 (5369791568) // CALL压入
栈顶 (低地址) ← sp指向
```

---

## 🏗️ test_func函数执行过程

### 📊 第1行：NVAR 2 - 创建test_func栈帧

**VM指令**：
```
(5369790472)     NVAR 2
```

**NVAR指令执行**：
```c
// NVAR 2: 创建test_func的栈帧
*--sp = (int)bp; bp = sp; sp = sp - 2;
```

**test_func栈帧创建过程**：
```
NVAR执行前:
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 5 (参数)           
└── 返回地址 (5369791568) // CALL压入
栈顶 (低地址) ← sp指向

NVAR 2 执行后（按bp偏移顺序）:
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 5 (bp+2)           // 参数
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = ?     // test_func局部变量
└── a3 (bp-2) = ?     // test_func局部变量
栈顶 (低地址) ← sp指向
```

**注意**：test_func的栈帧结构（按bp偏移顺序）：
- bp+3: result1的地址（在test_func栈帧外）
- bp+2: 参数a1=5
- bp+1: 返回地址
- bp+0: 旧bp（NVAR压入）← bp指向这里
- bp-1: a2局部变量
- bp-2: a3局部变量

### 📈 第2-5行：a3 = 40

**VM指令**：
```
(5369790488)     LEA  -2    // ax = a3的地址
(5369790504)     PUSH       // 压入a3的地址
(5369790512)     IMM  40     // ax = 40
(5369790528)     SI          // 将40存储到a3
```

**指令分析**：
1. **LEA -2**：计算a3的地址 (bp + (-2))
2. **PUSH**：将a3的地址压入栈
3. **IMM 40**：加载常量40到ax
4. **SI**：将ax的值存储到a3

**完整的栈状态变化**：

**LEA -2, PUSH 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 5 (bp+2)           // 参数
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = ?     // 局部变量
├── a3 (bp-2) = ?     // 局部变量
└── a3的地址           // 压入的地址
栈顶 (低地址) ← sp指向
```

**IMM 40, SI 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 5 (bp+2)           // 参数
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = ?     // 局部变量
└── a3 (bp-2) = 40    // 局部变量 ← 已赋值
栈顶 (低地址) ← sp指向
```

### 🔄 第6-13行：a2 = a1 + 1

**VM指令**：
```
(5369790536)     LEA  -1    // ax = a2的地址
(5369790552)     PUSH       // 压入a2的地址
(5369790560)     LEA  2     // ax = a1的地址 (bp+2)
(5369790576)     LI         // ax = a1的值 = 5
(5369790584)     PUSH       // 压入a1的值
(5369790592)     IMM  1     // ax = 1
(5369790608)     ADD        // ax = 5 + 1 = 6
(5369790616)     SI         // 将6存储到a2
```

**指令分析**：
1. **LEA -1**：计算a2的地址 (bp + (-1))
2. **PUSH**：将a2的地址压入栈
3. **LEA 2**：计算a1的地址 (bp + 2) ← 参数在bp+2位置
4. **LI**：加载a1的值到ax
5. **PUSH**：将a1的值压入栈
6. **IMM 1**：加载常量1到ax
7. **ADD**：ax = 栈顶值 + ax (a1 + 1)
8. **SI**：将结果存储到a2

**完整的栈状态变化**：

**LEA -1, PUSH 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 5 (bp+2)           // 参数
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = ?     // 局部变量
├── a3 (bp-2) = 40    // 局部变量
└── a2的地址           // 压入的地址
栈顶 (低地址) ← sp指向
```

**LEA 2, LI, PUSH 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 5 (bp+2)           // 参数
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = ?     // 局部变量
├── a3 (bp-2) = 40    // 局部变量
├── a2的地址           
└── 5 (a1的值)         // 压入的值
栈顶 (低地址) ← sp指向
```

**IMM 1, ADD, SI 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 5 (bp+2)           // 参数
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = 6     // 局部变量 ← 已赋值
└── a3 (bp-2) = 40    // 局部变量
栈顶 (低地址) ← sp指向
```

### 📊 第14-38行：嵌套块中的赋值和printf调用

**VM指令**：
```
(5369790624)     LEA  2     // a1 = 20
(5369790640)     PUSH
(5369790648)     IMM  20
(5369790664)     SI

(5369790672)     LEA  -1    // a2 = a1 + 1
(5369790688)     PUSH
(5369790696)     LEA  2
(5369790712)     LI
(5369790720)     PUSH
(5369790728)     IMM  1
(5369790744)     ADD
(5369790752)     SI

(5369790760)     IMM  5370839056  // printf("inner: a1=%d, a2=%d, a3=%d\n", a1, a2, a3)
(5369790776)     PUSH
(5369790784)     LEA  2
(5369790800)     LI
(5369790808)     PUSH
(5369790816)     LEA  -1
(5369790832)     LI
(5369790840)     PUSH
(5369790848)     LEA  -2
(5369790864)     LI
(5369790872)     PUSH
(5369790880)     PRTF
(5369790888)     DARG 4
```

**执行后栈状态**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 20 (bp+2)          // 参数 ← 已修改
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = 21    // 局部变量 ← 已修改
└── a3 (bp-2) = 40    // 局部变量
栈顶 (低地址) ← sp指向
```

### 🔄 第39-79行：更多嵌套块和printf调用

**继续执行**：
- 内层嵌套块：a1 = 30, a2 = 31
- printf调用：输出"inner: a1=30, a2=31, a3=40"
- 外层printf调用：输出"outer: a1=30, a2=31, a3=40"

**最终栈状态**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── main的旧bp
├── a1 = 10    // main的局部变量
├── result1 = ? // main的局部变量
├── result1的地址       
├── 30 (bp+2)          // 参数 ← 最终值
├── 返回地址 (bp+1)   // CALL压入
├── 旧bp (bp+0)       ← bp指向这里 (NVAR压入)
├── a2 (bp-1) = 31    // 局部变量 ← 最终值
└── a3 (bp-2) = 40    // 局部变量
栈顶 (低地址) ← sp指向
```

---

## 🎯 函数调用机制详解

### 📊 函数调用的完整流程

**函数调用涉及的关键要素**：

#### 1. **CALL指令执行**
```c
// CALL指令: {*--sp = (int)(pc+1); pc = (int*)*pc;}
*--sp = (int)(pc+1);    // 保存返回地址到栈
pc = (int*)*pc;         // 跳转到目标函数
```

**关键要点**：
- **保存返回地址**：`pc+1`（下一条指令的地址）压入栈
- **跳转执行**：`pc`跳转到目标函数的地址
- **栈指针更新**：`sp`指向返回地址

#### 2. **NVAR指令执行**
```c
// NVAR指令: {*--sp = (int)bp; bp = sp; sp = sp - *pc++;}
*--sp = (int)bp;        // 保存旧bp到栈
bp = sp;                // 设置新bp指向栈顶
sp = sp - *pc++;        // 分配局部变量空间
```

**关键要点**：
- **保存旧bp**：当前函数的bp压入栈
- **设置新bp**：bp指向新栈帧的基址
- **分配空间**：为局部变量分配栈空间

#### 3. **栈帧结构**（按bp偏移顺序）
```
栈底 (高地址)
├── 参数2 (bp+3)
├── 参数1 (bp+2)      ← 函数参数
├── 返回地址 (bp+1)   ← CALL压入
├── 旧bp (bp+0)       ← bp指向这里
├── 局部变量1 (bp-1)  ← 局部变量
├── 局部变量2 (bp-2)
└── ...
栈顶 (低地址) ← sp指向
```

#### 4. **RET指令执行**
```c
// RET指令: {sp = bp; bp = (int*)*sp++; pc = (int*)*sp++;}
sp = bp;                    // 恢复栈指针到旧bp位置
bp = (int*)*sp++;           // 恢复旧bp
pc = (int*)*sp++;           // 跳转回返回地址
```

**关键要点**：
- **恢复栈指针**：`sp`回到调用前的状态
- **恢复基指针**：`bp`恢复到调用者的bp
- **跳转返回**：`pc`跳转到返回地址

#### 5. **sp恢复机制详解**

**为什么`sp = bp`能保证回到调用前状态？**

关键在于理解`bp`的作用和栈帧的创建过程：

**栈帧创建时的状态**：
```c
// NVAR指令执行时：
*--sp = (int)bp;        // 保存旧bp到栈
bp = sp;                // 设置新bp指向栈顶
sp = sp - *pc++;        // 分配局部变量空间
```

**关键理解**：
- **NVAR执行后**：`bp`指向**旧bp**的位置（栈帧基址）
- **函数执行期间**：`sp`在局部变量区域移动，但`bp`始终指向栈帧基址
- **RET执行时**：`sp = bp`让`sp`回到**旧bp**的位置

**具体过程**：
```
调用前状态：
栈底 (高地址)
├── 其他数据...
├── 旧bp (调用者的bp)
└── 栈顶 (低地址) ← sp指向

CALL + NVAR后（按bp偏移顺序）：
栈底 (高地址)
├── 其他数据...
├── 参数 (bp+2)
├── 返回地址 (bp+1)
├── 旧bp (bp+0)       ← bp指向这里
├── 局部变量 (bp-1)
├── 局部变量 (bp-2)
└── 栈顶 (低地址) ← sp指向

RET执行 sp = bp 后：
栈底 (高地址)
├── 其他数据...
├── 参数 (bp+2)       ← 这些数据被"丢弃"
├── 返回地址 (bp+1)   ← 这些数据被"丢弃"
├── 旧bp (bp+0)       ← sp指向这里（回到调用前状态）
├── 局部变量 (bp-1)   ← 这些数据被"丢弃"
├── 局部变量 (bp-2)   ← 这些数据被"丢弃"
└── 栈顶 (低地址)
```

**保证机制**：
1. **NVAR保存旧bp**：在栈帧基址位置保存调用者的bp
2. **bp指向基址**：函数执行期间bp始终指向栈帧基址
3. **RET恢复sp**：`sp = bp`让sp回到栈帧基址，即调用前状态
4. **栈帧销毁**：局部变量区域被"丢弃"，不再访问

**为什么这样设计？**
- **简单高效**：不需要计算栈帧大小，直接使用bp恢复
- **安全可靠**：bp始终指向栈帧基址，不会出错
- **标准做法**：这是x86汇编中栈帧管理的标准方法

#### 6. **RET执行后的关键理解**

**RET执行后的栈状态**：
```
栈底 (高地址)
├── 其他数据...
├── 参数 (bp+2)       ← 这些数据被"丢弃"
├── 返回地址 (bp+1)   ← 这些数据被"丢弃"
├── 旧bp (bp+0)       ← sp指向这里（回到调用前状态）
├── 局部变量 (bp-1)   ← 这些数据被"丢弃"
├── 局部变量 (bp-2)   ← 这些数据被"丢弃"
└── 栈顶 (低地址)
```

**关键理解**：
- **RET执行后**：`sp`指向**函数参数**的位置
- **等待DARG**：`sp`指向参数位置，等待`DARG`指令清理参数
- **栈的对称性**：调用时压入参数，返回后需要清理参数

**完整流程**：
1. **函数调用前**：参数压栈，`sp`指向参数
2. **CALL指令**：压入返回地址，`sp`指向返回地址
3. **NVAR指令**：创建栈帧，`sp`指向局部变量
4. **函数执行**：`sp`在局部变量区域移动
5. **RET指令**：`sp = bp`，`sp`回到参数位置
6. **DARG指令**：清理参数，`sp`回到调用前状态

**DARG指令的作用**：
```c
// DARG 1: sp = sp + 1;
sp = sp + 1;    // 清理1个参数，sp回到调用前状态
```

**为什么需要DARG？**
- **栈的平衡**：调用时压入了参数，返回后必须清理
- **避免栈溢出**：不清理参数会导致栈不断增长
- **标准做法**：这是函数调用约定的标准要求

### 🔍 函数调用的完整要点总结

#### **调用前准备**：
1. **参数压栈**：所有函数参数按顺序压入栈
2. **目标地址准备**：函数地址在CALL指令中

#### **CALL指令执行**：
1. **保存返回地址**：`pc+1`压入栈（下一条指令地址）
2. **跳转执行**：`pc`跳转到目标函数
3. **栈指针更新**：`sp`指向返回地址

#### **NVAR指令执行**：
1. **保存旧bp**：当前bp压入栈
2. **设置新bp**：bp指向新栈帧基址
3. **分配空间**：为局部变量分配栈空间

#### **函数执行期间**：
1. **参数访问**：通过`bp+2`, `bp+3`等访问参数
2. **局部变量访问**：通过`bp-1`, `bp-2`等访问局部变量
3. **栈操作**：临时数据通过栈操作

#### **RET指令执行**：
1. **恢复栈指针**：`sp = bp`（回到调用前状态）
2. **恢复基指针**：`bp = (int*)*sp++`（恢复旧bp）
3. **跳转返回**：`pc = (int*)*sp++`（跳转到返回地址）

#### **返回后处理**：
1. **DARG指令**：清理函数参数
2. **SI指令**：处理返回值（如果需要）

### 🎯 关键理解

**栈帧的生命周期**：
- **创建**：CALL + NVAR指令
- **使用**：函数执行期间
- **销毁**：RET指令

**寄存器的作用**：
- **pc**：程序计数器，控制执行流程
- **bp**：基指针，指向当前栈帧基址
- **sp**：栈指针，指向栈顶
- **ax**：累加器，存储计算结果和返回值

**内存访问模式**：
- **参数访问**：`bp + 正偏移`
- **局部变量访问**：`bp + 负偏移`
- **全局变量访问**：直接地址访问

---

## 🔄 函数返回过程

### 📊 第77-79行：return a2

**VM指令**：
```
(5369791328)     LEA  -1    // ax = a2的地址
(5369791344)     LI         // ax = a2的值 = 31
(5369791352)     RET        // 返回，ax = 31
```

**RET指令执行**：
```c
// RET指令: {sp = bp; bp = (int*)*sp++; pc = (int*)*sp++;}
sp = bp;                    // 恢复栈指针
bp = (int*)*sp++;           // 恢复旧bp
pc = (int*)*sp++;           // 跳转回main函数
```

**返回到main函数后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = 10    // 局部变量
├── result1 (bp-2) = ? // 局部变量
├── result1的地址       
├── 5 (参数)           
└── 返回地址 (5369791568) // CALL压入
栈顶 (低地址) ← sp指向
```

**DARG 1 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = 10    // 局部变量
├── result1 (bp-2) = ? // 局部变量
└── result1的地址       
栈顶 (低地址) ← sp指向
```

**SI 执行后**：
```
栈底 (高地址)
├── EXIT (退出码)
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
├── tmp (临时指针)
├── 旧bp (bp+0)       ← bp指向这里
├── a1 (bp-1) = 10    // 局部变量
└── result1 (bp-2) = 31 // 局部变量 ← 已赋值！
栈顶 (低地址) ← sp指向
```

### 📈 main函数继续执行

**第99-113行：printf调用和返回**
```
(5369791592)     IMM  5370839168  // printf("Results: result1=%d\n", result1)
(5369791608)     PUSH
(5369791616)     LEA  -2
(5369791632)     LI
(5369791640)     PUSH
(5369791648)     PRTF
(5369791656)     DARG 2

(5369791672)     IMM  5370839192  // printf("a1=%d\n", a1)
(5369791688)     PUSH
(5369791696)     LEA  -1
(5369791712)     LI
(5369791720)     PUSH
(5369791728)     PRTF
(5369791736)     DARG 2

(5369791752)     IMM  0           // return 0
(5369791768)     RET
```

**main函数RET指令执行**：
```c
// RET指令: {sp = bp; bp = (int*)*sp++; pc = (int*)*sp++;}
sp = bp;                    // 恢复栈指针
bp = (int*)*sp++;           // 恢复旧bp
pc = (int*)*sp++;           // 跳转到返回地址
```

**main函数返回后的栈状态**：
```
栈底 (高地址)
├── EXIT (退出码)        ← pc现在指向这里！
├── PUSH (指令)
├── argc (参数)
├── argv (参数)
└── tmp (临时指针)
栈顶 (低地址) ← sp指向
```

**EXIT指令执行**：
```c
// EXIT指令: {printf("exit(%lld)\n", *sp); return *sp;}
printf("exit(0)\n");        // 输出退出码
return 0;                   // 程序退出
```

**最终执行结果**：
```
main: a1=10
inner: a1=20, a2=21, a3=40
inner: a1=30, a2=31, a3=40
outer: a1=30, a2=31, a3=40
Results: result1=31
a1=10
exit(0)
```

---

## 🎯 总结

### 📊 完整的执行流程

**1. PC启动**：
- PC指向main函数 (5369791360)
- 初始化栈，设置main函数参数

**2. main函数执行**：
- 创建栈帧：a1=10, result1=?
- 调用printf输出"main: a1=10"
- 调用test_func(5)

**3. test_func函数执行**：
- 创建栈帧：a1=5(参数), a2=?, a3=?
- 赋值：a3=40, a2=6
- 嵌套块：a1=20, a2=21
- 内层嵌套：a1=30, a2=31
- 调用printf输出结果
- 返回a2=31

**4. 返回到main函数**：
- result1=31
- 调用printf输出"Results: result1=31"
- 调用printf输出"a1=10"
- 返回0

**5. 程序退出**：
- main函数执行RET指令
- pc跳转到栈底的EXIT指令
- 执行EXIT指令，输出"exit(0)"
- 程序正常退出

### 🔍 栈的变化特点

**栈帧管理**：
- **main栈帧**：a1=10, result1=31
- **test_func栈帧**：a1=5(参数), a2=31, a3=40
- **函数调用**：通过CALL/RET管理栈帧切换
- **返回值处理**：通过PUSH保存目标地址，SI存储返回值

**变量遮蔽**：
- **全局变量a1**：被main和test_func的局部变量遮蔽
- **参数遮蔽**：test_func的a1参数遮蔽全局变量
- **局部变量遮蔽**：各函数内的局部变量遮蔽全局变量

**内存访问**：
- **参数访问**：通过LEA 2访问(bp+2位置)
- **局部变量访问**：通过LEA -1/-2访问(bp-1/-2位置)
- **全局变量访问**：通过IMM指令访问数据段地址

**栈操作完整性**：
- **PUSH指令的必要性**：保存中间结果和地址
- **SI指令的工作方式**：从栈顶弹出地址进行存储
- **栈状态跟踪**：每一步都需要完整跟踪栈的变化

这就是CPC编译器执行test.c的完整过程，从main函数入口到栈变化的详细分析！
